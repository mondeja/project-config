{
  rules: [
    {
      // The directory `src/` and the file `src/.keep` must exist
      // or will be created
      files: ["src/", "src/.keep"],
    },
    {
      // The file `data.json` is a file or will be created (FIXABLE)
      files: ["data.json"],

      // Using JMESPath we can query serialized files to expect
      // that certain conditions match or edit theirs contents:
      JMESPathsMatch: [
        // Always initialize the file in `fix` to an empty object
        // to trigger all other assertions as errors
        ["null", true, "`{}`"],

        // Specify that a value must be certain constant (FIXABLE):
        ["string_constant", "my-string"], // "my-string"
        ["number_constant", 42], // 42
        ["boolean_constant", true], // true
        ["null_constant", null], // null

        // If you need to create an intermediate object,
        // define it of type `array` or `object` (FIXABLE):
        ["type(an_object)", "object"],
        ["type(an_array)", "array"],

        // This also works lately in nested arrays an objects (FIXABLE):
        ["type(an_object.a_nested_array)", "array"],
        ["type(an_object.a_nested_object)", "object"],
        ["type(an_object.a_nested_empty_string)", "string"],
        ["type(an_object.a_nested_object.a_subnested_null)", "null"],

        // You can make your own editions manually specifying a fix query.
        // For example, here if `boolean_constant` is `true`, the value
        // of `conditional_contant` will be setted as 'enabled' (MANUAL FIX):
        [
          "boolean_constant",
          false,
          "set(@, 'conditional_constant', 'enabled')",
        ],
        // or delete by key from a dict using `unset()`:
        [
          // Note that this expression will be always treated as an
          // error and fixed because the previous is setting
          // `conditional_constant` to `enabled` (MANUAL FIX):
          "contains(keys(@), 'conditional_constant')",
          false,
          "unset(@, 'conditional_constant')",
        ],
        [
          "contains(keys(@), 'conditional_constant')",
          true,
          "set(@, 'conditional_constant', 'enabled')",
        ],

        // the function `set` defined a pair key-value in an object
        // and returns the updated object

        // If you need to update the current object you can use `update()`:
        //                                                    (MANUAL FIX)
        [
          "boolean_constant",
          false,
          "update(@, {string_constant: 'my-string', other_string_constant: 'my-other-string', other_boolean_constant: `false`})",
        ],

        // The function `insert()` can be used to insert an element in an array.
        // If `an_array` is empty, set `an_array` in the root object (`@`) to be
        // an empty array with the value `77` prepended at index 0 (MANUAL FIX):
        [
          "op(length(an_array), '>', `0`)",
          true,
          "set(@ , 'an_array', insert(`[]`, `0`, `77`))",
        ],

        // With the function `deepmerge` we can make more complex updates of nested
        // nodes following different strategies, even by type:
        //
        //   - Update the root object and a the nested dictionary ```an_object```
        //     using the default conservative merging strategy (MANUAL FIX):
        [
          "type(an_object.deepmerged_array)",
          "array",
          "deepmerge(@, {deepmerged_string: 'deep string', an_object: {deepmerged_array: [`1`, `2`, `3`, `4`, `[\"to-the-deep\"]`]}})",
        ],
        //     Use 'always_merger' at the thid argument of `deepmerge()` to override
        //     the keys of the objects if are found:
        //
        //   deepmerge(@, {key1: 'value', key2: {key3: [`1`, `2`, `3`]}}, 'always_merger')
      ],

      crossJMESPathsMatch: [
        //
        // Working with online sources
        // ---------------------------
        //
        // You can use the verb `crossJMESPathsMatch` to ensure that your data matches
        // with an online source.
        //
        // For example, if you want to ensure that the value of the key `license`
        // is OSI approved SPDX license identifier according to the official SPDX
        // repository you can use:
        [
          "license",
          [
            "gh://spdx/license-list-data@v3.17/json/licenses.json",
            "licenses[?isOsiApproved] | [?!isDeprecatedLicenseId].licenseId",
          ],
          "contains([1], [0])",
          true,
        ],
        // Here we are defining a Github protocol, which allows to query remote files
        // with the syntax `gh://<owner>/<repository>(@v<version>)?/<path>`
      ],
    },
  ],
}
